# Initialize memory
CLR $0 F
SETQ 0
SW $0 0
SETQ 55
SW $0 1
SETQ 32
SW $0 2
SETQ 0
SW $0 3
SETQ 13
SW $0 7
CPLC
Step2:
   SETQ 3      # Q = 3
   MOV $1 F    # $1 = 3
   LW $1 0     # Now Q contains D[3], divisor MSB  
   RRC Q       # Q >> 1
   CLR $3 F    # $3 = 0
   SW $3 3     # D[3] = Q
   SETQ 2      # Q = 2
   MOV $1 F    # $1 = 2
   LW $1 0     # Now Q contains D[2], divisor LSB
   RRC Q       # Q >> 1
   CLR $3 F    # $3 = 0
   SW $3 2     # D[2] = Q
   CLRC        # Clear Carry
   SETQ 0      # Q = 0
   MOV $1 F    # $1 = 0
   LW $1 0     # Now Q contains D[0], dividend MSB  
   MOV $2 F    # $2 = D[0], safe copy
   SETQ 1      # Q = 1
   MOV $1 F    # $1 = 1
   LW $1 0     # Now Q contains D[1], dividend LSB  
   MOV $3 F    # $3 = D[1], dividend LSB safe copy
   SETQ 2      # Q = 2
   MOV $0 F    # $0 = 2
   LW $0 0     # Now Q contains D[2], divisor LSB
   SUBC $3 Q   # Q = Divdend[1] - Q
   CLR $0 F    # $0 = 0
   SW $0 1     # D[1] = Q
   SETQ 3      # Q = 3
   MOV $0 F    # $0 = 3
   LW $0 0     # Now Q contains D[3], divisor MSB
   SUBC $2 Q    # Q = Dividend[0] - Q
   CLR $0 F    # $0 = 0
   SW $0 0     # D[0] = Q
   BGE Step3   # JNC
   MOV $2 Q    # Q = D[0], safe copy
   SW $0 0     # D[0] = Q
   MOV $3 Q    # Q = D[1], safe copy
   SW $0 1     # D[1] = Q
Step3:
   CPLC        # Invert Carry
   SETQ 5      # Q = 5
   MOV $0 F    # $0 = 5
   LW $0 0     # Now Q = D[5], result LSB
   RLC Q       # Shift carry flag into temporary result
   SW $0 0     # D[5] = Q
   SETQ 4      # Q = 4
   MOV $0 F    # $0 = 4
   LW $0 0     # Now Q = D[4], result MSB
   RLC Q       # Shift carry flag into temporary result
   SW $0 0     # D[4] = Q
   SETQ 7      # Q = 7
   MOV $0 F    # $0 = 7
   LW $0 0     # Now Q = D[7], counter
   CLR $0 F    # $0 = 0
   MOV $1 F    # $1 = Q
   DEC $1 F    # #1 = D[7] - 1
   MOV $1 Q    # Q = $1 (D[7] - 1)
   sw $0 7     # D[7] = D[7] - 1
   CMPZ $0
   BNE Repeat2
   JUMP CHECKER
Repeat2:
   JUMP Step2
CHECKER:
   HALT